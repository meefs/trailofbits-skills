version: 0.1.0

# Rust-specific signals
sensitive_name_regex:
  - "(?i)\\b(secret|key|seed|priv|sk|shared[_-]?secret|nonce|token)\\b"

explicit_sensitive_markers:
  - "#\\[secret\\]"
  - "Secret<"
  - "secrecy::Secret"

approved_wipe_funcs:
  - "zeroize"
  - "Zeroize::zeroize"
  - "zeroize::Zeroize::zeroize"
  - "explicit_bzero"   # if using FFI

# Async suspension: secret-named local live across .await
async_suspension_pattern:
  category: NOT_ON_ALL_PATHS
  severity: high
  detail: "secret local live across .await suspension point — stored in heap-allocated Future state machine; ZeroizeOnDrop covers stack only"

# LLVM IR confidence gates for Rust (check_llvm_patterns.py)
# These findings require the named evidence; without it, downgrade to needs_review.
rust_ir_confidence_gates:
  OPTIMIZED_AWAY_ZEROIZE:
    requires: ir_diff_evidence
    note: "volatile store count drop O0→O2 or non-volatile memset required"
  STACK_RETENTION:
    requires: alloca_lifetime_evidence
    note: "alloca with @llvm.lifetime.end but no store volatile required"

# Semantic source patterns for semantic_audit.py
rust_semantic_patterns:
  copy_derive_on_sensitive:
    category: SECRET_COPY
    severity: critical
    detail: "Copy derive on sensitive type — all assignments are untracked duplicates, no Drop ever runs"
  no_zeroize_no_drop:
    category: MISSING_SOURCE_ZEROIZE
    severity: high
    detail: "Sensitive type has no Zeroize, ZeroizeOnDrop, or Drop implementation"
  zeroize_without_trigger:
    category: MISSING_SOURCE_ZEROIZE
    severity: high
    detail: "Zeroize trait impl exists but no ZeroizeOnDrop or Drop to trigger it automatically"
  partial_drop:
    category: PARTIAL_WIPE
    severity: high
    detail: "Drop impl zeroes some secret fields but not all"
  zeroize_on_drop_heap_fields:
    category: PARTIAL_WIPE
    severity: medium
    detail: "ZeroizeOnDrop on type with Vec/Box heap fields — capacity bytes beyond len may not be zeroed"
  clone_on_zeroizing_type:
    category: SECRET_COPY
    severity: medium
    detail: "Clone on zeroizing type — each clone is an independent allocation that must be independently zeroed"
  from_into_non_zeroizing:
    category: SECRET_COPY
    severity: medium
    detail: "From/Into returning non-zeroizing type — bytes escape into caller's ownership in a non-zeroizing container"
  ptr_write_bytes_no_fence:
    category: OPTIMIZED_AWAY_ZEROIZE
    severity: medium
    detail: "ptr::write_bytes without following compiler_fence/volatile — DSE-eligible; confirm at IR layer"
  cfg_feature_wrapping_drop:
    category: NOT_ON_ALL_PATHS
    severity: medium
    detail: "#[cfg(feature=...)] wrapping Drop/Zeroize — zeroing absent when feature flag is off"
  debug_derive_on_sensitive:
    category: SECRET_COPY
    severity: low
    detail: "#[derive(Debug)] on sensitive type — secrets may appear in log output"
  serialize_derive_on_sensitive:
    category: SECRET_COPY
    severity: low
    detail: "#[derive(Serialize)] on sensitive type — serialization creates an uncontrolled copy of secret bytes"
  no_zeroize_crate:
    category: MISSING_SOURCE_ZEROIZE
    severity: low
    detail: "No zeroize crate in Cargo.toml — all manual zeroing lacks approved-API guarantee"
