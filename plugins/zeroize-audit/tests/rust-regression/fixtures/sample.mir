fn demo_async() -> Result<(), ()> {
    debug secret_key => _1;
    debug token => _2;
    _3 = <closure_capture as closure>::new(move _2);
    _4 = Err(());
    yield();
    return;
}

fn drop_in_place_secret() {
    debug secret_key => _5;
    drop(_5);
    return;
}

// Exercises detect_resume_with_live_secrets (MISSING_SOURCE_ZEROIZE/medium)
// and detect_drop_before_storagedead medium branch (no 'return' keyword).
fn unwind_only_secret() {
    debug secret_key => _6;
    drop(_6);
    resume;
}

// Exercises detect_aggregate_move_non_zeroizing (SECRET_COPY/medium):
// sensitive local moved into a non-Zeroizing struct.
fn wrap_secret_in_buffer() {
    debug secret_key => _7;
    _8 = PlainBuffer { data: move _7 };
    return;
}

// Exercises detect_ffi_call_with_secret (SECRET_COPY/high):
// sensitive local passed to a C FFI call (::c_ matches the FFI heuristic).
fn call_c_encrypt() {
    debug secret_key => _9;
    call c_crypto::c_encrypt(_9) -> [return: bb1, unwind: resume];
    bb1:
    return;
}
